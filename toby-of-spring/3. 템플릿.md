## 3장, 템플릿
템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을

자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

### p.210)
- 오류가 날 때마다 미처 반환되지 못한 Connection이 계속 쌓이면 어느 순간에 커넥션 풀에 여유가 없어지고
  리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.
  
### p.211)
- Connection이나 PreparedStatment에는 close() 메소드가 있다. 보통 리소스를 반환한다는 의미로 이해하는 것이 좋다.
- 보통 Pool 방식으로 운영된다. 미리 정해진 풀 안에 제한된 수의 리소스를 만들어 두고 필요할 때 이를 할당하고, 반환되면
  다시 풀에 넣는 방식으로 운영된다.
- 요청이 매우 많은 서버환경에서는 매번 새로운 리소스를 생성하는 대신 풀에 만들어둔 리소스를 돌려가며 사용하는 편이 훨씬
  유리하다.
- 대신, 사용한 리소스는 빠르게 반환해야 한다. 그렇지 않으면 풀에 있는 리소스가 고갈되고 결국 문제가 발생한다. close() 메소드는
  사용한 리소스를 돌려주는 역할을 한다.

### p.212)
- null 상태의 변수에 close() 메소드를 호출하면 NullPointerException이 발생할 테니 
  이럴 땐 close() 메소드를 호출하면 안된다.
  
### p.218)
템플릿 메소드 패턴의 적용
- 템플릿 메소드 패턴은 상속을 통해 기능을확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은
  추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.
  
### p.219)
- 서브클래스들이 이미 클래스 레벨에서 컴파일 시점에 이미 그 관계가 결정되어 있다.따라서 그 관계에 대한 유연성이
  떨어져 버린다. 상속을 통해 확장을 꾀하는 템플릿 메소드 패턴의 단점이 고스란히 드러난다.

전략 패턴의 적용
- 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다. 전략 패턴은 
  OCP 관점에서 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.
- 특정 확장 기능은 전략 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것이다.  

### p.224)
마이크로 DI
- DI의 가장 중요한 개념은 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것이다.
- 이렇게 DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 `마이크로 DI`라고도 한다.
  또는 코드에 의한 DI라는 의미로 수동 DI라고 부를 수도 있다.
  
### p.228)
중첩 클래스의 종류
- 다른 클래스 내부에 정의되는 클래스를 `중첩(nested class) 클래스`라고 한다. 중첩 클래스는 독립적 오브젝트로 만들어 질 수 있는
  `스태틱 클래스`와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 `내부 클래스`로 구분된다.
  
- 내부 클래스는 다시 범위에 따라 세 가지로 구분된다. 멤버 필드처럼 오브젝트 레벨에 정의되는 `멤버 내부 클래스`와 `메소드 레벨`에
  정의되는 `로컬 클래스`, 그리고 이름을 갖지 않는 `익명 내부 클래스`다. 익명 내부 클래스의 범위는 선언된 위치에 따라서 다르다.
  
로컬 클래스에는 여러 장점이 있다.
- 메소드 안에 로컬클래스를 집어 넣음으로써 마치 로컬 변수를 선언하듯이 선언할 수 있다. 덕분에 클래스 파일이 하나 줄고, 메소드 안에서 
  PreparedStatement 생성 로직을 함께 볼 수 있으니 코드를 이해하기도 좋다.
- 로컬 클래스는 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다.
  - 다만 내부 클래스에서 외부의 변수를 사용할때는 외부 변수는 반드시 final로 선언해줘야 한다. user 파라미터는 메소드 내부에서
    뱐경될 일이 없으므로 final로 선언해도 무방하다.
- 메소드마다 추가해야 했던 클래스 파일을 하나 줄일 수 있다는 것도 장점이고 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다
  쓸 수 있다는 것도 큰 장점이다.
 
### p.230)
익명 내부 클래스
- 클래스 생성과 오브젝트 생성이 결합된 형태로 만들어지며, 상속한 클래스나 구현할 인터페이스를 생성자 대신 사용해서 다음과 같은
  형태로 만들어 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.

익명 내부 클래스는 선언과 동시에 오브젝트를 생성한다. 이름이 없기 때문에 클래스 자신의 타입을 가질 수 없고, 구현한 인터페이스 
타입의 변수에만 저장할 수 있다.

### p.236)
스프링 빈으로 DI
- jdbcContext는 DataSource와 달리 테스트에서도 다른 구현으로 대체해서 사용할 이유가 없다. 이런 경우는 굳이 인터페이스를
  두지 말고 강력한 결합을 가진 관계를 허용하면서 위에서 마한 두 가지 이유인, 싱글톤으로 만드는 것과 JdbcContext에 대한
  DI 필요성을 위해 스프링의 빈으로 등록해서 UserDao에 DI 되도록 만들어도 좋다.

### p.237)
코드를 이용하는 수동 DI
- 하나의 jdbcContext 오브젝트를 갖고 있게 하는 것이다. DAO 메소드에서 매번 만들어 사용한다면 수만, 수백만의 JdbcContext 오브젝트
  가 만들어 지겠지만, DAO마다 하나씩만 만든다면 기껏해야 DAO 개수만큼, 웬만큼 대형 프로젝트라고 하더라도 수백 개면 충분할 것이다.
- JdbcContext는 다른 빈을 인터페이스를 통해 간접적으로 의존하고 있다. 다른 빈을 의존하고 있다면, 의존 오브젝트를 DI를 통해
  제공받기 위해서라도 자신도 빈으로 등록돼야 한다고 했다.