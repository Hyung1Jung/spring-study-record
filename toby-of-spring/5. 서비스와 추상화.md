## 서비스와 추상화

### p.343)
- 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 
요청한다.
- 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.

### p.353)
- 트랜잭션이란 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자
성을 의미한다.
- 따라서 중간에 예외가 발생해서 작업을 완료할 수 없다면 아예 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야 한다. 이것이 바로 
`트랜잭션`이다.
  
### p.354)
- 두 가지 작업이 하나의 트랜잭션이 되려면, 두 번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우에는 앞에서 처리한
  SQL 작업도 취소시켜야 한다. 이런 취소 작업을 `트랜잭션 롤백`이라고 한다.
- 반대로 여러 개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서
  작업을 확정시켜야 한다. 이것을 `트랜잭션 커밋`이라고 한다.
  
JDBC 트랜잭션의 트랜잭션 경계설정
- 모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다. 시작하는 방법은 한 가지이지만 끝나느 방법은 두 가지다. 모든 작업을
  무효화하는 `롤백`과 모든 작업을 다 확정하는 `커밋`이다.
- 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 `트랜잭션의 경계`라고 부른다. 복잡한 로직의 흐름 사이에서
  정확하게 트랜잭션 경계를 설정하는 일은 매우 중요한 작업이다.
  
- JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서 일어난다. 트랜잭션의 시작과 종료는
  Connection 오브젝트를 통해 이뤄지기 때문이다.
- 트랜잭션이 한 번 시작되면 Commit() 또는 rollback() 메소드가 호출될 때까지의 작업이 하나의 트랜잭셭으로 묶인다. 
- commit() 또는 rollback()이 호출되면 그에 따라 작업 결과가 DB에 반영되거나 취소되고 트랜잭셔이 종료된다. 
- 일반적으로 작업중에 예외가 발생하면 트랜잭션을 롤백한다. 예외가 발생했다는건, 트랜잭션을 구성하는 데이터 엑세스 작업을 
  마무리할 수 없는 상황이거나 DV에 결과를 반영하면 안 되는 이유가 생겼기 때문이다.
- 이렇게 setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을
  `트랜잭션의 경계설정`이라고 한다. 트랜잭션의 경계는 하나의 Connection이 만들어지고 닫히는 범위 안에 존재한다는 점도
  기억해두자. 이렇게하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 `로컬 트랜잭션`이라고도 한다.

### p.357)
- 여러 번 DB에 업데이트를 해야 하는 작업을 하나의 트랜잭션으로 만들려면 어떻게 해야할까? 어떤 일련의 작업이 하나의 트랜잭션으로
  묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다.
  
### p.360)
트랜잭션 경계설정의 문제점
- 멀티스레드 환경에서는 공유하는 인스턴스 변수에 스레드별로 생성하는 정보를 저장하다가는 서로 덮어쓰는 일이 발생할 수 있다.

### p.361)
- 트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고,
  이후에 호출되는 DAO의 메소드에서는 Connection을 가져다가 사용하게 하는 것이다.
- 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를
  처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려는 없다.

### p.353)
- 스프링이 제공하는 트랜잭션 동기화 관리 클래스는 `TransactionSynchronizationManager`다.
- `DataSource`에서 `Connection`을 직접 가져오지 않고, 스프링이 제공하는 유틸리티 메소드를 쓰는 이유는
  이 `DataSourceUtils`의 getConnection() 메소드는 Connection 오브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기화에
  사용하도록 저장소에 바인딩해주기 떄문이다.

### p.365)
- 한 가지 궁금한 것이 있다. jdbcTemplate의 동작방식이다. 지금까지는 jdbcTemplate은 update()나 query() 같은 
  JDBC 작업의 템플릿 메소드를 호출하면 직접 Connection을 생성하고 종료하는 일을 모두 담당한다.
  
### p.366)
한 개 이상의 DB로의 작업을 하나의 트랜잭션으로 만드는건 JDBC의 Connection을 이용한 트랜잭션 방식인 로컬 트랜잭션으로는 불가능하다.
- 왜냐하면 로컬 트랜잭션은 하나의 DB Connection에 종속되기 떄문이다.
따라서 각 DB와 독립적으로 만들어지는 Connection을 통해서가 아니라,
- 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 `글로벌 트랜잭션` 방식을 사용해야 한다.

- 자바는 JDBC 외에 이런 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API인 JTA(Java Transaction API)를 제공하고 있다.

- 트랜잭션 매니저는 DB와 메시징 서버를 제어하고 관리하는 각각의 리소스 매니저와 XA 프로토콜을 통해 연결된다.
- 이를 통해 트랜잭션 매니저가 실제 DB와 메시징 서버의 트랜잭션을 종합적으로 제어할 수 있게 되는 것이다.
- 이렇게 JTA를 이용해 트랜잭션 매니저를 활용하면 여러 개의 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는
  `분산 트랜잭션` 또는 `글로벌 트랜잭션`이 가능해진다.
  
### p.369)
- 추상화란 하위 시스템의 공통점 뽑아내서 분리시키는 것을 말한다.
- 그렇게 하면 하위 시스템이 어떤 것인지 알지 못해도, 또는 하위 시스템이 바뀌더라도  일관된 방법으로 접근할 수가 있다.

- DB에서 제공하는 DB 클라이언트 라이브러리와 API는 서로 전혀 호환이 되지 않는 독자적인 방식으로 만들어져 있다. 
    - 하지만 모두 SQL을 이용하는 방식이라는 공통점이 있다.
- 이 공통점을 뽑아내 추상화한 것이 JDBC다.
    - JDBC라는 추상화 기술이 있기 때문에 자바의 DB 프로그램 개발자는 DB의 종류에 상관없이 일관된 방법으로 데이터 엑세스
      코드를 작성할 수가 있다.

### p.371) 
- 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 PlatformTransactionManager다. JDBC의 로컬 트랜잭션을
  이용한다면 PlatformTransactionManager를 구현한 DataSourceTransactionManeger를 사용하면 된다.
  
### p.372)
트랜잭션의 기술 설정의 분리
- 어떤 클래스든 스프링의 빈으로 등록할 떄 먼저 검토해야 할 것은 싱글톤으로 마들어져 어러 스레드에서 동시에 사용해도 괜찮은 가 하는 
  점이다.
- 상태를 갖고 있고, 멀티스레드 환경에서 안전하지 않은 클래스를 빈으로 무작정 등록하면 심각한 문제가 발행하기 때문이다.  
