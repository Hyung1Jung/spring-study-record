## AOP

### p.410) 트랜잭션 분리에 따른 테스트 수정
- @Autowired는 기본적으로 타입을 이용해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 
  이름을 이용해 빈을 찾는다.

### P.413) 트랜잭션 경계설정 코드 분리의 장점
- 첫째, 이제 비즈니스 로직을 담당하고 있는 UserServiceImple의 코드를 작성할 떄는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지
  않아도 된다.
- 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실해오디도록 만들기만 하면 된다. 
  따라서 언제든지 트랜잭션을 도입할 수 있다.
- 두 번째 장점은 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.

### p.413) 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 작은 단위로 쪼개서 테스트하는 것이다.
- 작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 떄문이다. **반대로** 테스트에서 오류가 발견됐을 떄 그 테스트가 진행되는
  동안 실행된 코드의 양이 많다면 그 원인을 찾기가 매우 힘들어질 수도 있다. 
- 또한 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다. 테스트할 대상이 크고 복잡하면 테스트를 만들기도
  그만큼 어렵고, 만들었다 해도 충분하지 못할 수 있다.
- 클래스 하나가 동작하도록 테스트를 만드는 것과 클래스 수십 개가 얽히고 설혀서 동작하도록 만드는 것 중에서 어떤 것이 논리적인 오류를
  찾기 쉬울지는 분명하다.
- 테스트 대상의 단위가 커지면 테스트를 만들기도 쉽지 않다.
- 논리적인 오류가 발생해서 결과가 바르게 나오지 않았을 떄 그 원인을 찾기도 어려워진다.
- 어쩌면 테스트가 실패한 코드를 살펴보는 것만으로는 충분하지 못해서, 디버거를 사용해 한 줄씩 실행해보면서 어느 부분에 오류가
  있는지 일일이 확인해봐야 할 수도 있다. 
- 차라리 처음부터 작은 단위로 테스트하면서 진행해왔다면, 나중에 덩치가 커져도 어렵지 않게 오류를 찾아낼 수 있다. 작은 단위의
  테스트로 검증한 부분은 제외하고 접근할 수 있기 때문이다.
  
따라서 테스트는 작은 단위로 하면 좋다. 하지만 작은 단위로 테스트하고 싶어도 그럴 수 없는 경우가 많다. 테스트 대상이 다른 오브젝트와 
환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### p.415)
- 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.

### p.420)
- 하지만 실수로 사용될 위험이 있으므로 unsupportedOperationException을 던지게 해서 지원하지 않는 기능이라는 예외가
  발생하도록 만드는게 좋다.

### p.421)
- 컨테이너에서 가져온 UserService 오브젝트는 DI를 통해서 많은 의존오브젝트와 서비스, 외부 환경에 의존하고 있었다.
  이제는 완전히 고립돼서 테스트만을 위해 독립적으로 동작하는 테스트 대상을 사용할 것이기 때문에 스프링 컨테이너에서 빈을 가져올
  필요가 없다.
  
### p.423)
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라, 테스트 수행
  성능도 크게 향상된다. 테스트가 빨리 돌아가면 부담 없이 자주 테스트를 돌려볼 수 
  
### p.423)
- 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트
  하는 것을 `단위 테스트`라고 부르겠다.
- 반면에 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의
  리소스가 참여하는 테스트는 `통합 테스트`라고 부르겠다.
    - `통합 테스트`란 두 개 이상의 단위가 결합해서 동작하면서 테스트가 수행되는 것이라고 보면 된다.
- 스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 오브젝트를 테스트하는 것도 통합 테스트다.

단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지는 몇 가지 가이드라인을 살펴보자.

- 항상 단위 테스트를 먼저 고려한다.
- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트
  등의 테스트 대역을 이용하도록 테스트를 만든다. 단위 테스트는 작성도 간단하고 실행 속도도 빠르며 테스트 대상 외의 코드나
  환경으로부터 테스트 결과의 영향을 받지도 않기 때문에 가장 빠른 시간에 효과적인 테스트를 작성하기에 유리하다.
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
- 단위 테스트로 만들기가 어려운 코드도 있다. 대표적인게 DAO다. DAO는 그 자체로 로직을 담고 있기보다는 DB를 통해 로직을 수행하는
  인터페이스와 같은 역할을 한다. SQL을 JDBC를 통해 실행하는 코드만으로는 고립된 테스트를 작성하기가 힘들다. 작성한다고 해도 가치가
  없는 경우가 대부분이다. 따라서 DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적이다. DB를 사용하는 테스트는 DB에 테스트 데이터를
  준비하고, DB에 직접 확인을 하는 등의 부가적인 작업이 필요하다.
- DAO 테스트는 DB라는 외부 리소스를 사용하기 때문에 통합 테스트로 분류된다. 하지만 코드에서 보자면 하나의 기능 단위를 테스트하는 것이기도
  하다. DAO를 테스트를 통해 충분히 검증해두면, DAO를 이용하는 코드는 DAO 역할을 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다. 이후
  실제 DAO와 연동했을 때도 바르게 동작하리라고 확신할 수 있다. 물론 각각의 단위 테스트가 성공했더라도 여러 개의 단위를 연결해서 테스트
  하면 오류가 발생할 수도 있다. 하지만 충분한 단위 테스트를 거친다면 통합 테스트에서 오류가 발생할 확률도 줄어들고 발생한다 하더라도 쉽게 처리할
  수 있다.
- 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만,단위 테스트를 충분히 거쳤다면 통합 테스트의 
  부담은 상대적으로 줄어든다.
- 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 토압 테스트를 고려해 본다. 이때도 통합 테스트에 참여하는
  코드 중에서 가능한 많은 부분을 미리 단위 테스트로 검증해두는 게 유리하다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다. 가능하면 스프링의 지원 없이 직접 코드레벨의 DI를 사용하면서
  단위 테스트를 하는게 좋겠지만 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종
  있다. 이럴 떈 스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.
  
코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다. 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될
가능성이 높다. 만약 DI도 사용하지 않고, 비즈니스 로직과 로우레벨의 기술과 외부 환경과 성격이 다른 데이터 엑세스 기능들이 한데 모여
강하게 결합되어있는 코드였다면, 과연이런 테스트를 만들 수 나 있었을까?

### p.426)
Mockito 프레임워크
- Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 점이다. 간단한 메소드 호출만으로 다이내믹하게
  특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
- UserDao 인터페이스를 구현한 테스트용 목 오브젝트는 다음과 같이 Mockito의 스태틱 메소드를 한 번 호출해주면 만들어진다.
  mock() 메소드는 org.mockiot.Matchers 클래스에 정의된 스태틱 메소드다. 스태틱 임포트를 사용해 로컬 메소드처럼 호출하게 하면 편리하다.
  
### p.427)
Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 된다. 두 번째와 네 번째는 각각 필요한 경우에만 사용할 수 있다.
- 인터페이스를 이용해 목 오브젝트를만든다.
- 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수 있다.
- 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
- 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.