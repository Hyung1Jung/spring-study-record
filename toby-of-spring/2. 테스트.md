## 2장, 테스트

### p.145)
- 변하고 복잡해져가는 애플리케이션에 대응하는 첫 번쨰 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로
담아낼 수 있는 IoC/DI 같은 기술이라면 

**두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처 할 수 있는 자신감을 주는 테스트 기술**이다.

### p.146)
- 테스트란 결국 내가 에상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

- 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 

- 이를 통해 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이
제거됐다는 확신을 얻을 수 있다.

### p.149)
**작은 단위의 테스트**

- 테스트의 관심이 다르다면 테스트 할 대상을 분리하고 집중해서 접근해야 한다. 즉, 한 가지 관심에 집중할 수 있게
작은 단위로 만들어야 한다. 
- 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트**라고 한다.
- 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
- 사용할 DB의 상태를 테스트가 관장하고 있다면 이는 단위 테스트라고 해도 된다. 
  
다만 DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 그때는 단위 테스트로써의 가치가
없어진다. 즉, 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 하는 것이다.

### p.150) 
- 단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기
위해서다.
  
### p.151 ~ 152)
**자동 수행 테스트 코드**
- 테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다.
- 클래스를 분리하고 유연한 설계구조로 발전시키면서 테스트 코드를 넣을 위치를 결정하기가 애매하기 때문에 과거엔 별개의
  클래스를 만들고 그 안에 테스트 코드를 넣었었다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다.

- 개발을 일단 완료하고 실전에서 운영 중인 상황에서 코드를 수정하려고 한다면 아무리 간단한 수정이라고 하더라도
  이게 그럭저럭 돌아가는 전체 애플리케이션에 심각한 문제를 일으키지는 않을까 하는 두려움이 앞선다. 
  - 그럴 때 만들어둔 기능에 대한 테스트가 있다면 수정 후 빠르게 전체 테스트를 수행해서 수정 때문에 다른 기능에
    문제가 발생하지는 않는지 재빨리 확인하고, 성공한다면 마음에 확신을 얻을 수 있다.
 
### p.153)
**지속적인 개선과 점진적인 개발을 위한 테스트**
- 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이
  새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있다.

### ㅔ.154)
모든 테스트는 성공과 실패 두 가지 결과를 가질 수 있다.

- 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와,
- 테스트 작업 중에 에러가 발생하진 않았지만 그 결과가 기대한 것과 다르게 나오는 경우로 구분해 볼 수 있다.
전자를 **테스트 에러**, 후자를 **테스트 실패**로 구분해서 부르겠다.  
  
### p.157)
- 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다.
- 새로 만들 테스트는 Junit 프레임워크가 요구하는 조건 두 가지를 따라야한다. 첫째는 메소드가 `public`으로 선언돼야
  하는 것이고, 다른 하나는 메소드에 `Test`라는 애노테이션을 붙여주는 것이다.
  
### p.168)
단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어서는 안된다.
- DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도
  동일한 결과가 보장되도록 만들어야 한다.
  
### p.173)
```java
@Test(expected=EmptyResultDataAccessExceptiom.class)
```
@Test에 execpted를 추가해놓으면 보통의 테스트와는 반대로, 정상적으로 테스트 메소드를 마치면 테스트가 실패하고,
expected에서 지정한 예외가 던져지면 테스트가 성공한다.

### p.176)
**테스트 주도 개발**

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고,
테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다. 이를 `테스트 주도 개발`이라고 한다.

### p.181 ~ 182) 
**Junit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다**

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Brfore가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

또 한가지 **꼭** 기억해야 할 사항은 각 테스트 메소드를 실행할 떄 마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다.
한 번 만들어진 테스트 클ㄹ스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다.

**그런데, 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 것일까?**
- Junit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를
  만들게 했다.
  
테스트 메소드의 일부에서만 공통적으로 사용되는 코드가 있다면 어떻게 해야할까?
- 이때는 @Before를 사용하기보다는 일반적으로 메소드 추출 방법을 써서 메소드를 분리하고 테스트 메소드에서 직접 호출해
  사용하도록 만드는 편이 낫다.
- 아니면 아예 공통적인 특징을 지닌 테스트 메소드를 모아서 별도의 테스트 클래스로 만드는 방법도 생각해 볼 수 있다.

픽스처
- 테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로
  사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.


